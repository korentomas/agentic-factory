name: Agent Write

# Triggered by the AgentFactory orchestrator via GitHub API:
# POST /repos/{owner}/{repo}/dispatches
# { "event_type": "agent-task", "client_payload": { ... } }

on:
  repository_dispatch:
    types: [agent-task]

jobs:
  write:
    name: "Agent: Write Code"
    runs-on: ubuntu-latest
    timeout-minutes: 90

    # Isolated service containers â€” fresh databases for every agent run.
    # Using the same pattern as test.yml so agents have a full working stack.
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: app_test
        ports:
          - "5432:5432"
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      neo4j:
        image: neo4j:5.14
        env:
          NEO4J_AUTH: neo4j/testing123
          NEO4J_PLUGINS: '["apoc"]'
          NEO4J_dbms_security_procedures_unrestricted: apoc.*
        ports:
          - "7687:7687"
          - "7474:7474"
        options: >-
          --health-cmd "wget --no-verbose --tries=1 --spider http://localhost:7474 || exit 1"
          --health-interval 15s
          --health-timeout 10s
          --health-retries 10
          --health-start-period 30s

      redis:
        image: redis:7-alpine
        ports:
          - "6379:6379"
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Validate payload
        id: validate
        run: |
          # Fail fast if required fields are missing
          if [ -z "${{ github.event.client_payload.clickup_task_id }}" ]; then
            echo "::error::Missing clickup_task_id in dispatch payload"
            exit 1
          fi
          if [ -z "${{ github.event.client_payload.title }}" ]; then
            echo "::error::Missing title in dispatch payload"
            exit 1
          fi
          echo "task_id=${{ github.event.client_payload.clickup_task_id }}" >> "$GITHUB_OUTPUT"
          echo "correlation_id=${{ github.event.client_payload.correlation_id }}" >> "$GITHUB_OUTPUT"
          echo "complexity=${{ github.event.client_payload.complexity }}" >> "$GITHUB_OUTPUT"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # MUST use GitHub App token â€” not GITHUB_TOKEN.
          # Commits made with GITHUB_TOKEN do NOT trigger CI workflows.
          # This is a hard GitHub policy to prevent infinite loops.
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 0

      - name: Create agent branch
        id: branch
        run: |
          BRANCH="agent/cu-${{ steps.validate.outputs.task_id }}"
          git config user.name "AgentFactory Bot"
          git config user.email "agent@agentfactory.dev"

          # Clean up stale branch from previous failed runs
          git push origin --delete "$BRANCH" 2>/dev/null || true
          git branch -D "$BRANCH" 2>/dev/null || true

          git checkout -b "$BRANCH"
          git push origin "$BRANCH"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Install dependencies
        run: pip install -e ".[dev]" 2>/dev/null || true
        # || true: orchestrator's deps don't need to be installed in the target repo.
        # Target repos should have their own install step here.

      # â”€â”€ Plan-first protocol for complex tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # For high-complexity tickets, generate an ExecPlan (PLANS.md) before writing code.
      # This gives humans a chance to review the approach before 40 turns of code generation.
      # See: https://cookbook.openai.com/articles/codex_exec_plans
      # â”€â”€ Provider configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Supports Anthropic direct, OpenRouter, Bedrock, Vertex, or any gateway.
      # Set ANTHROPIC_API_KEY for direct, or OPENROUTER_API_KEY + CLAUDE_SETTINGS
      # with {"env":{"ANTHROPIC_BASE_URL":"https://openrouter.ai/api"}}
      # See docs/providers.md for full configuration.

      - name: Generate ExecPlan (complex tasks only)
        if: ${{ github.event.client_payload.complexity == 'high' }}
        uses: anthropics/claude-code-action@v1
        env:
          ANTHROPIC_BASE_URL: ${{ secrets.ANTHROPIC_BASE_URL }}
          ANTHROPIC_AUTH_TOKEN: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token }}
          settings: ${{ secrets.CLAUDE_SETTINGS }}
          allowed_bots: "agentfactory-bot[bot]"
          show_full_output: "true"
          prompt: |
            Read CLAUDE.md and ARCHITECTURE.md first.

            Write a PLANS.md ExecPlan for this ticket. Required sections:

            ## Purpose & Big Picture
            What does this change accomplish? Why does it matter?

            ## Context & Orientation
            Full file paths you'll touch. Defined jargon. Interfaces you'll call.

            ## Plan of Work
            Checklist of steps with checkboxes. Mark [ ] todo, [x] done, [~] in progress.

            ## Concrete Steps
            Exact commands you'll run, exact functions you'll add/modify, expected output.

            ## Validation & Acceptance
            Observable behavior that proves the task is complete. Specific, not vague.
            ("GET /health returns 200" not "it works")

            ## Interfaces & Dependencies
            Exact function signatures you'll add or change. Types included.

            Write PLANS.md then STOP. Do not write any code yet.

            ---
            Ticket title: ${{ github.event.client_payload.title }}
            Ticket description:
            ${{ github.event.client_payload.description }}
          claude_args: "--max-turns 10 --model ${{ vars.CLAUDE_OPUS_MODEL || 'claude-opus-4-6' }}"

      - name: Capture plan costs
        if: ${{ github.event.client_payload.complexity == 'high' }}
        id: plan_cost
        run: |
          if [ -f /home/runner/work/_temp/claude-execution-output.json ]; then
            # File is NDJSON â€” cost data is in the last line (result object)
            LAST_LINE=$(tail -1 /home/runner/work/_temp/claude-execution-output.json)
            COST=$(echo "$LAST_LINE" | jq -r '.total_cost_usd // 0' 2>/dev/null || echo "0")
            TURNS=$(echo "$LAST_LINE" | jq -r '.num_turns // 0' 2>/dev/null || echo "0")
            DURATION=$(echo "$LAST_LINE" | jq -r '.duration_ms // 0' 2>/dev/null || echo "0")
          else
            COST="0"; TURNS="0"; DURATION="0"
          fi
          echo "cost=$COST" >> "$GITHUB_OUTPUT"
          echo "turns=$TURNS" >> "$GITHUB_OUTPUT"
          echo "duration=$DURATION" >> "$GITHUB_OUTPUT"

      - name: Commit ExecPlan
        if: ${{ github.event.client_payload.complexity == 'high' }}
        run: |
          if [ -f PLANS.md ]; then
            git add PLANS.md
            git commit -m "plan: ExecPlan for cu-${{ steps.validate.outputs.task_id }}"
            git push origin "${{ steps.branch.outputs.branch }}"
          fi

      # â”€â”€ Main coding step â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Claude Sonnet: action-biased, strong tool use, fast.
      # Opus used for planning/review; Sonnet for implementation.
      - name: Write code
        id: agent_write
        uses: anthropics/claude-code-action@v1
        env:
          ANTHROPIC_BASE_URL: ${{ secrets.ANTHROPIC_BASE_URL }}
          ANTHROPIC_AUTH_TOKEN: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token }}
          settings: ${{ secrets.CLAUDE_SETTINGS }}
          allowed_bots: "agentfactory-bot[bot]"
          prompt: |
            You are working on a development task from ClickUp.

            Read CLAUDE.md and ARCHITECTURE.md before writing any code.
            If PLANS.md exists, follow it â€” you wrote it in the planning step.

            Task title: ${{ github.event.client_payload.title }}

            Task description:
            ${{ github.event.client_payload.description }}

            Risk tier: ${{ github.event.client_payload.risk_tier }}

            Requirements:
            - Follow all patterns in CLAUDE.md exactly
            - Every new function needs tests
            - Run `pytest` before finishing â€” tests must pass
            - Do not stop until tests are green

            Environment:
            - DATABASE_URL=postgresql://postgres:postgres@localhost:5432/app_test
            - NEO4J_URI=bolt://localhost:7687
            - NEO4J_PASSWORD=testing123
            - REDIS_URL=redis://localhost:6379
          claude_args: "--max-turns 40 --model ${{ vars.CLAUDE_SONNET_MODEL || 'claude-sonnet-4-6' }} --allowedTools 'Read,Write,Edit,Bash,Glob,Grep,MultiEdit'"

      - name: Capture write costs
        id: write_cost
        run: |
          if [ -f /home/runner/work/_temp/claude-execution-output.json ]; then
            # File is NDJSON â€” cost data is in the last line (result object)
            LAST_LINE=$(tail -1 /home/runner/work/_temp/claude-execution-output.json)
            COST=$(echo "$LAST_LINE" | jq -r '.total_cost_usd // 0' 2>/dev/null || echo "0")
            TURNS=$(echo "$LAST_LINE" | jq -r '.num_turns // 0' 2>/dev/null || echo "0")
            DURATION=$(echo "$LAST_LINE" | jq -r '.duration_ms // 0' 2>/dev/null || echo "0")
          else
            COST="0"; TURNS="0"; DURATION="0"
          fi
          echo "cost=$COST" >> "$GITHUB_OUTPUT"
          echo "turns=$TURNS" >> "$GITHUB_OUTPUT"
          echo "duration=$DURATION" >> "$GITHUB_OUTPUT"

      - name: Commit agent changes
        run: |
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "feat(agent): ${{ github.event.client_payload.title }}

          Task: cu-${{ steps.validate.outputs.task_id }}
          Correlation: ${{ steps.validate.outputs.correlation_id }}"
            git push origin "${{ steps.branch.outputs.branch }}"
          fi

      - name: Create pull request
        id: create_pr
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # Push any remaining changes (in case agent already committed)
          git push origin "${{ steps.branch.outputs.branch }}" || true

          # Check there are actually changes to PR
          if git diff --quiet origin/main..HEAD; then
            echo "::error::No code changes were produced by the agent"
            exit 1
          fi

          TASK_ID="${{ steps.validate.outputs.task_id }}"
          SOURCE="${{ github.event.client_payload.source }}"
          ISSUE_NUM="${{ github.event.client_payload.issue_number }}"

          # Build source link based on trigger type
          if [ "$SOURCE" = "github-issue" ] && [ -n "$ISSUE_NUM" ]; then
            SOURCE_LINE="**GitHub Issue:** #${ISSUE_NUM}"
            CLOSES_LINE="Closes #${ISSUE_NUM}"
          else
            SOURCE_LINE="**ClickUp Task:** ${TASK_ID}"
            CLOSES_LINE=""
          fi

          # Compute agent cost stats
          PLAN_COST="${{ steps.plan_cost.outputs.cost }}"
          PLAN_COST="${PLAN_COST:-0}"
          PLAN_TURNS="${{ steps.plan_cost.outputs.turns }}"
          PLAN_TURNS="${PLAN_TURNS:-0}"
          PLAN_DURATION_MS="${{ steps.plan_cost.outputs.duration }}"
          PLAN_DURATION_MS="${PLAN_DURATION_MS:-0}"
          PLAN_DURATION_S=$(echo "scale=1; ${PLAN_DURATION_MS} / 1000" | bc 2>/dev/null || echo "0")

          WRITE_COST="${{ steps.write_cost.outputs.cost }}"
          WRITE_COST="${WRITE_COST:-0}"
          WRITE_TURNS="${{ steps.write_cost.outputs.turns }}"
          WRITE_TURNS="${WRITE_TURNS:-0}"
          WRITE_DURATION_MS="${{ steps.write_cost.outputs.duration }}"
          WRITE_DURATION_MS="${WRITE_DURATION_MS:-0}"
          WRITE_DURATION_S=$(echo "scale=1; ${WRITE_DURATION_MS} / 1000" | bc 2>/dev/null || echo "0")

          TOTAL_COST=$(echo "${PLAN_COST} + ${WRITE_COST}" | bc 2>/dev/null || echo "0")

          PR_URL=$(gh pr create \
            --draft \
            --title "${{ github.event.client_payload.title }}" \
            --body "## Agent-Written PR

          ${SOURCE_LINE}
          **Correlation ID:** ${{ steps.validate.outputs.correlation_id }}
          **Risk Tier:** ${{ github.event.client_payload.risk_tier }}
          ${CLOSES_LINE}

          This PR was written by AgentFactory. Review the changes carefully.

          - [ ] Code reviewed by human
          - [ ] Tests pass
          - [ ] No anti-patterns from CLAUDE.md

          ---
          ðŸ“Š **Agent Stats** (total: \$${TOTAL_COST})
          | Step | Cost | Turns | Duration |
          |------|------|-------|----------|
          | Plan | \$${PLAN_COST} | ${PLAN_TURNS} | ${PLAN_DURATION_S}s |
          | Write | \$${WRITE_COST} | ${WRITE_TURNS} | ${WRITE_DURATION_S}s |" \
            --base main \
            --head "${{ steps.branch.outputs.branch }}" \
            2>&1)

          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "Created PR: $PR_URL"

      # â”€â”€ Callback to orchestrator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Always runs â€” even if prior steps failed â€” so orchestrator is never
      # left waiting for a run that silently died.
      - name: Callback to orchestrator
        if: always()
        env:
          ORCHESTRATOR_URL: ${{ secrets.ORCHESTRATOR_URL }}
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          STATUS="${{ job.status }}"
          PR_URL="${{ steps.create_pr.outputs.pr_url }}"

          if [ -n "$ORCHESTRATOR_URL" ]; then
            curl --retry 3 --retry-delay 5 \
              -X POST "${ORCHESTRATOR_URL}/callbacks/agent-complete" \
              -H "Content-Type: application/json" \
              -H "X-Callback-Secret: ${CALLBACK_SECRET}" \
              -d "{
                \"clickup_task_id\": \"${{ steps.validate.outputs.task_id }}\",
                \"correlation_id\": \"${{ steps.validate.outputs.correlation_id }}\",
                \"run_id\": \"${{ github.run_id }}\",
                \"branch\": \"${{ steps.branch.outputs.branch }}\",
                \"pr_url\": \"${PR_URL}\",
                \"status\": \"${STATUS}\"
              }" \
              --fail-with-body || echo "::warning::Callback to orchestrator failed"
          else
            echo "No ORCHESTRATOR_URL configured â€” skipping callback"
            echo "Status: ${STATUS}, PR: ${PR_URL}"
          fi
